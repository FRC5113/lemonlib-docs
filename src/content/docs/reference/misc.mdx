---
title: Misc
description: Random Misc functions
---
{/*In lemonlib this file is named LemonLib/lemonlib/util/rand.py we should realy make it misc.py I thought it was like random functions*/}

## Purpose
These functiosn serve a variety of purposes that we could not fit anywhre else

## Add to files
```py

from lemonlib.util import *
# Will import all the random utility functions

```

## Methods / Functions
{/*
Will get file return the windows or the RoboRio file location
Also curve docs is a mess
also there is a function called "f" but I think it is meant to be private so I am not defining it
also what the fuck is the function "linear curve"??? (I am also confused about ollive_curve and cubic_curve)
*/}
```py
def clamp(val: float, min: float, max: float) -> float
#Returns val, restricted between min and max

def is_red() -> bool
#Returns true if you are on red team

def get_file() ->
#Gets the path of the current file on the RoboRio (or simmilar, I think)

def curve(
    mapping: Callable[[float], float],
    offset: float,
    deadband: float,
    max_mag: float,
    absolute_offset: bool = True,
) -> Callable[[float], float]:
    """Return a function that applies a curve to an input.

    Arguments:
    mapping -- maps input to output
    offset -- added to output, even if the input is deadbanded
    deadband -- when the input magnitude is less than this,
        the input is treated as zero
    max_mag -- restricts the output magnitude to a maximum.
        If this is 0, no restriction is applied.
    absolute_offset -- If true, applies offset always (even when deadbanded),
        If false, adds sign(input_val) * offset or 0 in the deadband
    """

#Ryan I am confused about the purpppose of these two
def ollie_curve(
    scalar: float = 1.0,
    offset: float = 0.0,
    deadband: float = 0.0,
    max_mag: float = 0.0,
    absolute_offset: bool = True,
) -> Callable[[float], float]:
    return curve(
        lambda x: scalar * x * abs(x), offset, deadband, max_mag, absolute_offset
    )


def cubic_curve(
    scalar: float = 1.0,
    offset: float = 0.0,
    deadband: float = 0.0,
    max_mag: float = 0.0,
    absolute_offset: bool = True,
) -> Callable[[float], float]:
    return curve(lambda x: scalar * x ** 3, offset, deadband, max_mag, absolute_offset)


def SnapX(x: float  y: float) -> float
#If abs(x) > abs(y) returns x, else 0

def SnapY(x: float, y: float) -> float
#If abs(y) > abs(x) returns y else 0

```